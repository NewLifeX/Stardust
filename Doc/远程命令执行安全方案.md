# 远程命令执行安全方案

## 概述

StarAgent 支持通过星尘平台远程执行 bash/cmd 命令，方便管理服务器集群。但由于 Agent 是开源的，客户端防护无效，因此**安全防护重点在平台侧**。

## 核心原则

1. **客户端可被绕过**：攻击者可以修改 Agent 源码去除防护
2. **平台是信任边界**：所有防护必须在平台侧实施
3. **审计优先于防御**：无法阻止时，确保可追溯

---

## 已实施：方案A - 增强审计日志

### Agent 侧改进

#### 1. 使用 WriteEvent 上报日志
```csharp
// 执行前：记录命令、超时、时间戳
WriteEvent("warn", "RunBash", $"执行命令：{cmd}，超时：{timeout}ms，时间：{now:yyyy-MM-dd HH:mm:ss}");

// 执行成功：记录耗时、输出长度
WriteEvent("info", "RunBash", $"执行成功，命令：{cmd}，耗时：{sw.ElapsedMilliseconds}ms，输出长度：{rs?.Length ?? 0}");

// 执行失败：记录错误信息
WriteEvent("error", "RunBash", $"执行失败，命令：{cmd}，耗时：{sw.ElapsedMilliseconds}ms，错误：{ex.Message}");
```

#### 2. 关键特性
- ? **不可删除**：`WriteEvent` 直接上报到星尘平台数据库
- ? **完整记录**：命令、时间、耗时、结果、错误信息
- ? **性能计量**：使用 `Stopwatch` 记录精确耗时
- ? **输出截断**：避免日志过大（超过1000字符截断）

#### 3. 审计日志字段
| 字段 | 说明 | 示例 |
|------|------|------|
| 类型 | warn/info/error | warn（执行前）、info（成功）、error（失败） |
| 动作 | RunBash/RunCmd | RunBash |
| 命令 | 完整命令内容 | `systemctl restart nginx` |
| 超时 | 超时时间（毫秒） | 30000 |
| 耗时 | 实际执行时间（毫秒） | 1523 |
| 输出长度 | 返回结果长度 | 256 |
| 时间戳 | 执行时间 | 2025-01-01 14:30:00 |
| 错误信息 | 失败原因 | Command execution timeout |

---

## 待实施：方案B - 平台侧防护

### 1. 数据库表设计

#### NodeCommand（节点命令记录表）
```sql
CREATE TABLE NodeCommand (
    Id BIGINT PRIMARY KEY AUTO_INCREMENT,
    NodeId INT NOT NULL COMMENT '节点ID',
    NodeName VARCHAR(100) COMMENT '节点名称',
    Command TEXT NOT NULL COMMENT '执行的命令',
    Type VARCHAR(20) COMMENT 'bash/cmd',
    
    -- 操作人信息
    OperatorId INT COMMENT '操作人ID',
    OperatorName VARCHAR(50) COMMENT '操作人姓名',
    OperatorRole VARCHAR(50) COMMENT '操作人角色',
    ClientIP VARCHAR(50) COMMENT '操作人IP',
    ClientLocation VARCHAR(100) COMMENT 'IP地理位置',
    
    -- 执行结果
    Success BOOLEAN COMMENT '是否成功',
    Duration INT COMMENT '耗时(ms)',
    OutputLength INT COMMENT '输出长度',
    ErrorMessage TEXT COMMENT '错误信息',
    
    -- 时间戳
    ExecuteTime DATETIME COMMENT '执行时间',
    CreateTime DATETIME NOT NULL,
    
    INDEX idx_node (NodeId, ExecuteTime),
    INDEX idx_operator (OperatorId, ExecuteTime),
    INDEX idx_time (ExecuteTime)
) COMMENT='节点命令执行记录（不可删除）';
```

#### NodeCommandAlert（敏感操作告警表）
```sql
CREATE TABLE NodeCommandAlert (
    Id BIGINT PRIMARY KEY AUTO_INCREMENT,
    CommandId BIGINT COMMENT '关联NodeCommand.Id',
    AlertType VARCHAR(50) COMMENT '告警类型：dangerous_command/batch_operation/abnormal_time/abnormal_ip',
    AlertLevel VARCHAR(20) COMMENT '告警级别：info/warn/error/critical',
    AlertMessage TEXT COMMENT '告警内容',
    
    -- 告警处理
    Status VARCHAR(20) DEFAULT 'pending' COMMENT '状态：pending/confirmed/ignored',
    Handler INT COMMENT '处理人ID',
    HandleTime DATETIME COMMENT '处理时间',
    HandleRemark TEXT COMMENT '处理备注',
    
    -- 通知状态
    NotifyDingTalk BOOLEAN DEFAULT FALSE COMMENT '是否已钉钉通知',
    NotifyWechat BOOLEAN DEFAULT FALSE COMMENT '是否已微信通知',
    NotifySMS BOOLEAN DEFAULT FALSE COMMENT '是否已短信通知',
    
    CreateTime DATETIME NOT NULL,
    
    INDEX idx_status (Status, CreateTime),
    INDEX idx_command (CommandId)
) COMMENT='节点命令告警记录';
```

### 2. 敏感命令检测规则

#### 危险关键字列表
```csharp
public static class DangerousPatterns
{
    // 系统破坏
    public static readonly String[] SystemDestruction = 
    [
        "rm -rf /",           // 删除根目录
        "mkfs",               // 格式化磁盘
        "dd if=/dev/zero",    // 写入零字节
        ":(){:|:&};:",        // Fork炸弹
    ];
    
    // 权限修改
    public static readonly String[] PermissionChange = 
    [
        "chmod 777",          // 危险权限
        "chown root",         // 改变所有者
        "passwd",             // 修改密码
        "useradd",            // 添加用户
        "userdel",            // 删除用户
    ];
    
    // 远程执行
    public static readonly String[] RemoteExecution = 
    [
        "curl.*|.*bash",      // 下载并执行
        "wget.*|.*sh",        // 下载并执行
        "nc -l",              // 反向shell
        "/dev/tcp",           // 网络后门
    ];
    
    // 网络安全
    public static readonly String[] NetworkSecurity = 
    [
        "iptables -F",        // 清空防火墙
        "systemctl stop firewalld", // 停止防火墙
        "ufw disable",        // 禁用防火墙
    ];
    
    // 系统控制
    public static readonly String[] SystemControl = 
    [
        "shutdown",           // 关机
        "reboot",             // 重启（注意：已有node/reboot指令）
        "init 0",             // 关机
        "init 6",             // 重启
    ];
}
```

#### 检测逻辑
```csharp
public class CommandSecurityChecker
{
    /// <summary>检测命令是否包含危险操作</summary>
    public static (Boolean isDangerous, String category, String pattern) CheckDangerous(String command)
    {
        foreach (var pattern in DangerousPatterns.SystemDestruction)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
                return (true, "系统破坏", pattern);
        }
        
        foreach (var pattern in DangerousPatterns.PermissionChange)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
                return (true, "权限修改", pattern);
        }
        
        foreach (var pattern in DangerousPatterns.RemoteExecution)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
                return (true, "远程执行", pattern);
        }
        
        foreach (var pattern in DangerousPatterns.NetworkSecurity)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
                return (true, "网络安全", pattern);
        }
        
        foreach (var pattern in DangerousPatterns.SystemControl)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
                return (true, "系统控制", pattern);
        }
        
        return (false, null, null);
    }
}
```

### 3. 异常行为检测

#### 批量操作检测
```csharp
// 检测：5分钟内同一用户执行命令超过100次
var count = NodeCommand.FindCount(
    _.OperatorId == userId && 
    _.ExecuteTime >= DateTime.Now.AddMinutes(-5)
);

if (count > 100)
{
    // 创建告警
    CreateAlert(commandId, "batch_operation", "error", 
        $"用户 {operatorName} 在5分钟内执行了 {count} 条命令，疑似批量攻击");
    
    // 临时冻结账号
    FreezeUser(userId, "批量操作告警，临时冻结30分钟");
    
    // 发送通知
    SendAlert("紧急", $"用户 {operatorName} 账号疑似被盗，已临时冻结");
}
```

#### 异常时间检测
```csharp
// 检测：凌晨2-5点执行命令 && 该用户从未在此时段操作
var hour = DateTime.Now.Hour;
if (hour >= 2 && hour < 5)
{
    var historyCount = NodeCommand.FindCount(
        _.OperatorId == userId && 
        _.ExecuteTime.Hour >= 2 && 
        _.ExecuteTime.Hour < 5 &&
        _.ExecuteTime < DateTime.Now.AddDays(-7) // 查7天前的历史
    );
    
    if (historyCount == 0)
    {
        CreateAlert(commandId, "abnormal_time", "warn",
            $"用户 {operatorName} 首次在凌晨 {hour} 点执行命令：{command}");
        
        SendAlert("警告", $"用户 {operatorName} 在异常时间段操作");
    }
}
```

#### 异常IP检测
```csharp
// 检测：操作IP与该用户历史IP地理位置相差>1000km
var lastLogin = UserLoginLog.FindLast(_.UserId == userId);
if (lastLogin != null && lastLogin.ClientIP != currentIP)
{
    var lastLocation = GetIPLocation(lastLogin.ClientIP);
    var currentLocation = GetIPLocation(currentIP);
    var distance = CalculateDistance(lastLocation, currentLocation);
    
    if (distance > 1000)
    {
        CreateAlert(commandId, "abnormal_ip", "error",
            $"用户 {operatorName} 从异常地点登录：{currentLocation}（距离上次登录 {distance}km）");
        
        // 要求二次验证
        RequireTwoFactorAuth(userId);
        
        SendAlert("严重", $"用户 {operatorName} 异常地点登录，请立即确认");
    }
}
```

### 4. 告警通知实现

#### 钉钉机器人通知
```csharp
public async Task SendDingTalkAlert(String title, String message, String level)
{
    var webhook = "https://oapi.dingtalk.com/robot/send?access_token=xxx";
    
    var color = level switch
    {
        "info" => "#00FF00",
        "warn" => "#FFA500",
        "error" => "#FF0000",
        "critical" => "#8B0000",
        _ => "#808080"
    };
    
    var content = new
    {
        msgtype = "markdown",
        markdown = new
        {
            title = title,
            text = $"## {title}\n\n" +
                   $"**级别**：{level}\n\n" +
                   $"**内容**：{message}\n\n" +
                   $"**时间**：{DateTime.Now:yyyy-MM-dd HH:mm:ss}\n\n" +
                   $"[查看详情](https://stardust.newlifex.com/deployment/nodecommand)"
        }
    };
    
    await HttpClient.PostJsonAsync(webhook, content);
}
```

#### 企业微信通知
```csharp
public async Task SendWechatAlert(String title, String message, String level)
{
    var webhook = "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx";
    
    var content = new
    {
        msgtype = "markdown",
        markdown = new
        {
            content = $"## {title}\n" +
                     $">级别：<font color=\"warning\">{level}</font>\n" +
                     $">内容：{message}\n" +
                     $">时间：{DateTime.Now:yyyy-MM-dd HH:mm:ss}\n" +
                     $"[查看详情](https://stardust.newlifex.com/deployment/nodecommand)"
        }
    };
    
    await HttpClient.PostJsonAsync(webhook, content);
}
```

### 5. 权限控制（RBAC）

#### 角色定义
```csharp
public enum NodeCommandPermission
{
    None = 0,          // 无权限
    View = 1,          // 查看节点
    ReadOnly = 2,      // 执行只读命令（ps/df/top等）
    Manage = 3,        // 执行管理命令（重启服务等）
    Dangerous = 4,     // 执行危险命令（删除文件/修改密码等）
    Admin = 5,         // 超级管理员
}
```

#### 权限检查
```csharp
public Boolean CheckPermission(Int32 userId, String command)
{
    var user = User.FindById(userId);
    var permission = GetCommandPermission(command);
    
    // 检查用户角色是否满足要求
    if (user.NodeCommandPermission < permission)
    {
        XTrace.WriteLine($"权限不足：用户 {user.Name} 权限为 {user.NodeCommandPermission}，命令需要 {permission}");
        return false;
    }
    
    return true;
}

private NodeCommandPermission GetCommandPermission(String command)
{
    // 只读命令
    if (Regex.IsMatch(command, "^(ps|top|df|free|ls|cat|tail|head|uptime|hostname)"))
        return NodeCommandPermission.ReadOnly;
    
    // 管理命令
    if (Regex.IsMatch(command, "^(systemctl restart|systemctl stop|systemctl start)"))
        return NodeCommandPermission.Manage;
    
    // 危险命令
    if (Regex.IsMatch(command, "^(rm|passwd|userdel|useradd|chmod|chown)"))
        return NodeCommandPermission.Dangerous;
    
    // 默认需要管理员权限
    return NodeCommandPermission.Admin;
}
```

### 6. 实施步骤

#### 第一阶段：基础审计（已完成）
- [x] Agent 侧使用 WriteEvent 记录日志
- [x] 记录命令执行前后的完整信息
- [x] 记录耗时和输出长度

#### 第二阶段：平台侧记录（待实施）
- [ ] 创建 NodeCommand 表
- [ ] 创建 NodeCommandAlert 表
- [ ] 实现命令记录接口
- [ ] 管理后台展示命令历史

#### 第三阶段：检测告警（待实施）
- [ ] 实现危险命令检测
- [ ] 实现异常行为检测
- [ ] 集成钉钉/企业微信告警
- [ ] 实现告警处理流程

#### 第四阶段：权限控制（待实施）
- [ ] 实现 RBAC 权限体系
- [ ] 权限检查拦截器
- [ ] 审批流程（可选）

---

## 附录：安全最佳实践

### 1. 最小权限原则
- 普通用户：只能查看节点状态
- 运维人员：可执行只读和管理命令
- 高级运维：可执行危险命令（需审批）
- 超级管理员：不受限制（但有审计）

### 2. 双因素认证
对于危险操作，要求：
1. 密码验证
2. 短信/邮箱验证码
3. 动态令牌（可选）

### 3. 操作留痕
- 所有命令永久保存
- 不允许删除审计日志
- 定期归档历史数据
- 关键操作实时告警

### 4. 定期审计
- 每周生成操作报告
- 异常行为人工复核
- 权限定期复查
- 安全策略持续优化

---

## 总结

远程命令执行功能的安全防护，**核心在平台侧**：

1. **Agent 侧**：详细的审计日志（已完成）
2. **平台侧**：权限控制 + 异常检测 + 实时告警（待实施）
3. **运营侧**：定期审计 + 应急响应

**记住**：即使攻击者攻破平台，完整的审计日志也能帮助追溯所有操作，这是最后一道防线。
