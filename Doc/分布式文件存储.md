# 分布式文件存储

## 背景

基于 ASP.NET 开发的 Web 应用，带有文件上传功能。把文件保存到本地 Uploads 目录后，再写一条文件信息到附件表 Attachment，业务表存储附件 id。业务模块需要获取文件时，根据附件 id 查询并从 Uploads 目录读取文件。

在分布式部署场景，应用部署了 ABCD 四台服务器，共用 MySql 数据库，此时附件表共用，每个节点都可以查询到附件信息。但是文件上传时只会存储在 ABCD 其中一台服务器本地，业务模块请求文件时，如果负载均衡 nginx 刚好没有路由到那台服务器，程序将无法获取文件。

引入 NAS 或者 OSS 等集中存储的方案增加了部署维护成本，不适合轻量级项目场景。

## 解决方案

Stardust 实现了轻量级的**分布式文件存储**方案，基于**写扩散**架构，通过事件总线自动同步文件到所有节点，无需依赖外部存储服务。

### 核心特性

1. **无中心化存储**：每个节点都存储完整文件副本，无需 NAS/OSS
2. **写扩散架构**：文件上传后自动广播到所有节点
3. **自动同步**：新节点加入后自动拉取缺失文件
4. **故障自愈**：文件丢失时可向集群请求重新同步
5. **灵活配置**：可配置节点仅提供服务或仅拉取文件

## 架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                         事件总线 (Redis)                      │
│  ┌──────────────────────┐    ┌────────────────────────┐    │
│  │ IEventBus<NewFileInfo>│    │ IEventBus<FileRequest> │    │
│  └──────────────────────┘    └────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
           ↑         ↓                    ↑         ↓
    ┌──────┴────┐    └────────┐    ┌────┴────┐    └────────┐
    │  节点 A    │    │  节点 B │    │  节点 C │    │  节点 D │
    │ /Uploads  │    │ /Uploads│    │ /Uploads│    │ /Uploads│
    └───────────┘    └─────────┘    └─────────┘    └─────────┘
           ↓               ↓               ↓               ↓
    ┌──────────────────────────────────────────────────────────┐
    │                   共享数据库 (MySQL)                       │
    │                 Attachment 附件表                          │
    └──────────────────────────────────────────────────────────┘
```

### 工作流程

#### 1. 文件上传流程

```
用户 → 节点A → 保存文件 → 写入附件表 → 发布 NewFileInfo → 事件总线
                                                              ↓
                                        ┌─────────────────────┴─────────┐
                                        ↓                     ↓         ↓
                                    节点B                 节点C      节点D
                                        ↓                     ↓         ↓
                                  检查本地文件          检查本地文件  检查本地文件
                                        ↓                     ↓         ↓
                              不存在/Hash错误       不存在/Hash错误  不存在/Hash错误
                                        ↓                     ↓         ↓
                              请求节点A下载文件    请求节点A下载文件  请求节点A下载文件
                                        ↓                     ↓         ↓
                                  保存到本地            保存到本地    保存到本地
```

#### 2. 文件请求流程（自愈机制）

```
节点D访问文件 → 文件不存在/Hash错误 → 发布 FileRequest → 事件总线
                                                           ↓
                                      ┌────────────────────┴────────┐
                                      ↓                   ↓         ↓
                                  节点A               节点B      节点C
                                      ↓                   ↓         ↓
                              检查本地文件         检查本地文件  检查本地文件
                                      ↓                   ↓         ↓
                              存在且Hash正确      存在且Hash正确  不存在
                                      ↓                   ↓
                          发布 NewFileInfo     发布 NewFileInfo
                                      ↓                   ↓
                                      └───────────┬───────┘
                                                  ↓
                                            事件总线
                                                  ↓
                                              节点D
                                                  ↓
                                          下载并保存文件
```

#### 3. 新节点加入流程

```
新节点E加入 → 定时扫描附件表 → 发现本地缺失文件 → 逐个发布 FileRequest
                                                            ↓
                                                        事件总线
                                                            ↓
                                                ┌───────────┴───────────┐
                                                ↓                       ↓
                                            现有节点                现有节点
                                                ↓                       ↓
                                        发布 NewFileInfo        发布 NewFileInfo
                                                ↓                       ↓
                                                └───────────┬───────────┘
                                                            ↓
                                                        新节点E
                                                            ↓
                                                    批量下载并保存
```

## 核心组件

### 1. IFileStorage 接口

```csharp
public interface IFileStorage
{
    /// <summary>发布新文件通知，告知其他节点文件已就绪</summary>
    Task PublishNewFileAsync(Int64 attachmentId, String? path, CancellationToken cancellationToken = default);
    
    /// <summary>请求文件，向其他节点索取缺失的文件</summary>
    Task RequestFileAsync(Int64 attachmentId, String? path, String? reason = null, CancellationToken cancellationToken = default);
    
    /// <summary>扫描并请求缺失的文件，返回请求数量</summary>
    Task<Int32> ScanFilesAsync(DateTime startTime, CancellationToken cancellationToken = default);
}
```

### 2. DefaultFileStorage 抽象类

提供分布式文件存储的核心逻辑，主要功能包括：

- **事件订阅**：订阅新文件通知和文件请求消息
- **文件拉取**：从源节点下载文件并校验哈希
- **文件发布**：向其他节点广播新文件可用
- **文件请求**：向其他节点请求缺失文件
- **定时扫描**：定期扫描并同步缺失文件

#### 关键属性

| 属性 | 说明 | 默认值 |
|------|------|--------|
| `Name` | 集群名称，相同名称的应用共享文件存储 | null |
| `NodeName` | 当前节点名称 | `Runtime.ClientId` |
| `RootPath` | 文件存储根路径 | - |
| `DownloadUri` | 文件下载接口地址模板 | `/cube/file?id={Id}` |
| `EnableProvide` | 是否响应其他节点的文件下载请求 | `true` |
| `EnableFetch` | 是否主动拉取其他节点发布的新文件 | `true` |

#### 关键方法

| 方法 | 说明 |
|------|------|
| `InitializeAsync` | 初始化，订阅事件总线 |
| `PublishNewFileAsync` | 发布新文件通知 |
| `OnNewFileInfoAsync` | 处理新文件消息，拉取文件 |
| `FetchFileAsync` | 从源节点拉取文件 |
| `RequestFileAsync` | 发布文件请求 |
| `OnFileRequestAsync` | 处理文件请求消息，响应请求 |
| `ScanFilesAsync` | 扫描并请求缺失文件 |
| `GetMissingAttachments` | 查询缺失的附件（虚方法，子类实现） |

### 3. 消息类

#### NewFileInfo - 新文件通知消息

```csharp
public class NewFileInfo : IFileInfo
{
    public Int64 Id { get; set; }           // 附件ID
    public String Name { get; set; }        // 文件名
    public String Path { get; set; }        // 相对路径
    public String Hash { get; set; }        // MD5哈希
    public Int64 Length { get; set; }       // 文件大小
    public String SourceNode { get; set; }  // 源节点名称
    public String InternalAddress { get; set; } // 内网地址
    public String ExternalAddress { get; set; } // 外网地址
    public String TraceId { get; set; }     // 追踪ID
}
```

#### FileRequest - 文件请求消息

```csharp
public class FileRequest : IFileInfo
{
    public Int64 Id { get; set; }           // 附件ID
    public String Name { get; set; }        // 文件名
    public String Path { get; set; }        // 相对路径
    public String Hash { get; set; }        // MD5哈希
    public String RequestNode { get; set; } // 请求节点名称
    public String Reason { get; set; }      // 请求原因
}
```

## 配置说明

### StarServer / StarWeb 配置项

在 `StarServerSetting` 或 `StarWebSetting` 中配置：

| 配置项 | 说明 | 默认值 | 建议 |
|--------|------|--------|------|
| `FileStorageProvide` | 是否响应其他节点的文件下载请求 | `true` | 所有节点建议开启 |
| `FileStorageFetch` | 是否主动拉取其他节点发布的新文件 | `false` | 根据部署场景调整 |

### 典型部署场景配置

#### 场景1：标准集群部署（推荐）

所有节点独立部署，各自存储文件：

```json
// 所有节点
{
  "FileStorageProvide": true,  // 提供文件服务
  "FileStorageFetch": true     // 拉取其他节点文件
}
```

**特点**：每个节点都有完整副本，高可用性，推荐用于生产环境。

#### 场景2：StarWeb + StarServer 同机部署

StarWeb 和 StarServer 部署在同一服务器，共享附件目录：

```json
// StarWeb
{
  "FileStorageProvide": true,  // 提供文件服务
  "FileStorageFetch": true     // 拉取文件
}

// StarServer（同机部署）
{
  "FileStorageProvide": true,  // 提供文件服务
  "FileStorageFetch": false    // 不拉取（避免重复）
}
```

**特点**：避免同一台服务器上的两个实例同时拉取文件导致冲突。

#### 场景3：只读节点

某些节点只提供服务，不主动同步文件：

```json
{
  "FileStorageProvide": true,  // 提供文件服务
  "FileStorageFetch": false    // 不主动拉取
}
```

**特点**：适用于只需要从数据库读取已有文件的场景。

#### 场景4：禁用文件存储

完全不启用分布式文件存储功能：

```json
{
  "FileStorageProvide": false, // 不提供服务
  "FileStorageFetch": false    // 不拉取文件
}
```

**特点**：文件存储功能不会注入，节省资源。

## 使用方式

### 1. 文件上传后发布通知

```csharp
public class AttachmentService
{
    private readonly IFileStorage _fileStorage;
    
    public async Task<Attachment> UploadAsync(Stream stream, String fileName)
    {
        // 1. 保存文件到本地
        var path = Path.Combine(_uploadPath, fileName);
        await File.WriteAllBytesAsync(path, await stream.ReadBytesAsync());
        
        // 2. 计算哈希并写入数据库
        var attachment = new Attachment
        {
            Name = fileName,
            Path = path,
            Hash = File.ReadAllBytes(path).MD5().ToHex(),
            Length = new FileInfo(path).Length,
        };
        attachment.Insert();
        
        // 3. 发布新文件通知
        await _fileStorage.PublishNewFileAsync(attachment.Id, attachment.Path);
        
        return attachment;
    }
}
```

### 2. 文件访问时检查并请求

```csharp
public class FileController : Controller
{
    private readonly IFileStorage _fileStorage;
    
    public async Task<IActionResult> Download(Int64 id)
    {
        var attachment = Attachment.FindById(id);
        if (attachment == null) return NotFound();
        
        var filePath = Path.Combine(_uploadPath, attachment.Path);
        var fi = new FileInfo(filePath);
        
        // 检查文件是否存在且哈希正确
        if (!fi.Exists || !fi.VerifyHash(attachment.Hash))
        {
            // 发布文件请求，等待其他节点响应
            await _fileStorage.RequestFileAsync(id, attachment.Path, "file missing");
            
            // 延迟重试（实际应用中可能需要更复杂的重试机制）
            await Task.Delay(1000);
            
            if (!fi.Exists) return NotFound("文件正在同步中，请稍后重试");
        }
        
        return File(fi.OpenRead(), "application/octet-stream", attachment.Name);
    }
}
```

### 3. 新节点快速同步

```csharp
// 在应用启动或定时任务中调用
public class SyncService : IHostedService
{
    private readonly IFileStorage _fileStorage;
    private Timer _timer;
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        // 每小时扫描一次，同步最近30天的文件
        _timer = new Timer(async _ =>
        {
            var startTime = DateTime.Now.AddDays(-30);
            var count = await _fileStorage.ScanFilesAsync(startTime);
            if (count > 0)
                _logger.LogInformation("已请求同步 {count} 个缺失文件", count);
        }, null, TimeSpan.Zero, TimeSpan.FromHours(1));
        
        return Task.CompletedTask;
    }
}
```

## 技术要点

### 1. 事件总线

使用 `NewLife.Messaging.IEventBus` 实现消息发布订阅：

- **单机模式**：基于内存队列
- **集群模式**：基于 Redis Pub/Sub
- **自动发现**：集成 Stardust 注册中心，自动解析节点地址

### 2. 文件传输

- **HTTP 竞速下载**：同时尝试内网和外网地址，使用最快的连接
- **哈希校验**：下载完成后验证 MD5，确保文件完整性
- **断点续传**：支持大文件分片传输（可选）

### 3. 地址解析

节点间通信自动处理内外网地址：

```csharp
protected virtual AddressInfo BuildAddressInfo()
{
    var factory = ServiceProvider?.GetService<StarFactory>();
    
    return new AddressInfo
    {
        NodeName = NodeName,
        InternalAddress = factory?.InternalAddress,  // 内网地址
        ExternalAddress = factory?.ExternalAddress,  // 外网地址
    };
}
```

### 4. 定时扫描

每小时自动扫描缺失文件，确保最终一致性：

```csharp
private async Task OnScan(Object state)
{
    var rs = await ScanFilesAsync(_last, default).ConfigureAwait(false);
    if (rs >= 0)
        _last = DateTime.Now;
    else
        _scanTimer?.SetNext(10_000); // 失败时快速重试
}
```

## 性能优化

### 1. 批量处理

- 新文件消息异步处理，不阻塞上传
- 文件请求批量发送，减少消息数量

### 2. 缓存优化

- 节点地址缓存，避免重复解析
- HTTP 客户端池化，复用连接

### 3. 竞速下载

```csharp
// 同时尝试内外网地址，使用最快的连接
await client.DownloadFileRaceAsync(url, fileName, hash, false, cancellationToken);
```

### 4. 延迟队列

- 文件拉取失败时自动重试
- 扫描任务失败时快速重试

## 监控与日志

### 追踪埋点

所有关键操作都集成了 `ITracer` 追踪：

- `FileStorage-Init`：初始化
- `FileStorage-NewFile`：新文件处理
- `FileStorage-FetchFile`：文件拉取
- `FileStorage-FileRequest`：文件请求
- `FileStorage-ScanFiles`：扫描同步

### 日志输出

```
[Star]初始化分布式文件存储，节点：192.168.1.100@12345
使用[RedisCache]事件总线，订阅[Star]的应用通过消息队列分发事件。
收到新文件通知：{"Id":123,"Name":"test.jpg","SourceNode":"192.168.1.100@12345",...}
下载文件：test.jpg，来源：http://192.168.1.100:8080/cube/file?id=123
下载文件：test.jpg，成功：内网
```

## 故障处理

### 常见问题

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 文件未同步到新节点 | 新节点加入后未触发扫描 | 调用 `ScanFilesAsync` 手动同步 |
| 下载失败 | 网络不通或源节点已下线 | 其他节点会响应文件请求，自动切换源 |
| 文件哈希不匹配 | 文件损坏或传输错误 | 重新请求文件，覆盖本地副本 |
| 同机部署冲突 | 两个实例同时拉取文件 | 将一个实例的 `FileStorageFetch` 设为 `false` |

### 自愈机制

1. **写扩散失败**：其他节点发起文件请求，源节点重新发布
2. **文件损坏**：哈希校验失败时自动请求重新下载
3. **节点下线**：其他节点响应文件请求，提供副本
4. **定时扫描**：每小时自动检查并同步缺失文件

## 最佳实践

1. **生产环境**：所有节点开启 `FileStorageProvide` 和 `FileStorageFetch`
2. **同机部署**：只在一个实例开启 `FileStorageFetch`
3. **新节点上线**：启动后立即调用 `ScanFilesAsync` 快速同步
4. **文件清理**：删除文件前确认所有节点都不再需要
5. **监控告警**：监控文件请求失败次数，及时发现问题

## 总结

Stardust 分布式文件存储方案提供了轻量级、高可用的文件同步能力，适合以下场景：

- ✅ 中小规模 Web 应用集群部署
- ✅ 不希望引入 NAS/OSS 的轻量级项目
- ✅ 需要快速扩容节点的应用
- ✅ 对文件一致性有要求的业务

相比传统方案的优势：

- **零依赖**：无需 NAS/OSS 等外部服务
- **自动化**：文件自动同步，无需人工干预
- **高可用**：每个节点都有完整副本
- **易扩展**：新节点加入自动同步历史文件
- **可配置**：灵活的配置选项适应不同场景

