# 星尘监控性能优化方案

## 1. 问题诊断

### 1.1 性能瓶颈定位

根据慢 SQL 日志、埋点数据和运维经验，性能瓶颈集中在：

| 瓶颈点 | 严重程度 | 原因 |
|--------|---------|------|
| 延迟队列 UPDATE | **严重** | 4个延迟队列每60秒批量提交，产生大量 UPDATE 操作 |
| 流式计算频率 | 中等 | 每5秒执行一次，过于频繁 |
| 统计表查询 | 中等 | FindOrAdd 涉及数据库查询 |

### 1.2 关键数据指标

| 指标 | 实际值 | 说明 |
|------|--------|------|
| _queue 队列积压 | < 1000 条 | 远低于10万限制，流式计算压力不大 |
| 批量计算修正能力 | 完全修正 | 可以更激进地优化流式计算 |
| 告警延迟容忍度 | 3~5 分钟 | 统计频率可大幅降低 |
| 统计数据查看率 | < 1% | 99%+ 数据无人查看 |

### 1.3 当前配置分析

```csharp
// TraceStatService.cs 当前配置
public Int32 FlowPeriod { get; set; } = 5;      // 流式计算：每5秒
public Int32 BatchPeriod { get; set; } = 30;    // 批量计算：每30秒

// 延迟队列配置（都是60秒提交一次）
private readonly DayQueue _dayQueue = new() { Period = 60 };
private readonly HourQueue _hourQueue = new() { Period = 60 };
private readonly MinuteQueue _minuteQueue = new() { Period = 60 };
private readonly AppMinuteQueue _appMinuteQueue = new() { Period = 60 };
```

**问题分析**：

1. **流式计算过于频繁**：每5秒执行一次，但队列积压仅1000条，完全没必要
2. **延迟队列提交过于频繁**：4个队列每60秒各提交一次 = 每分钟4次批量 UPDATE
3. **计算冗余**：流式计算对4个统计维度（天/小时/分钟/应用分钟）都做增量累加

---

## 2. 优化方案

### 2.1 核心思路

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              优化核心思路                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 降低流式计算频率：5秒 → 30秒（队列积压<1000，完全够用）                  │
│                                                                             │
│  2. 延长延迟队列提交周期：60秒 → 180秒（减少2/3的UPDATE）                   │
│                                                                             │
│  3. 精简流式计算：只计算分钟级，小时/天级交给批量计算                        │
│                                                                             │
│  4. 批量计算降频：30秒 → 60秒（告警容忍3-5分钟，60秒足够）                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 方案对比

| 配置项 | 当前值 | 优化值 | 效果 |
|--------|--------|--------|------|
| FlowPeriod | 5秒 | 30秒 | CPU 降低 80%（流式计算） |
| BatchPeriod | 30秒 | 60秒 | CPU 降低 50%（批量计算） |
| 延迟队列 Period | 60秒 | 180秒 | UPDATE 减少 67% |
| 流式计算维度 | 4个 | 2个 | 内存操作减少 50% |

### 2.3 预期效果

| 指标 | 当前 | 优化后 | 改善 |
|------|------|--------|------|
| 每分钟流式计算次数 | 12次 | 2次 | -83% |
| 每分钟批量 UPDATE 次数 | 4次 | 1.3次 | -67% |
| CPU 占用 | 80%+ | 30%- | -60% |
| 数据库 IO | 高 | 低 | -60% |
| 告警延迟 | 1~2分钟 | 2~3分钟 | 可接受 |

---

## 3. 具体实施

### 3.1 第一阶段：调整参数（低风险）

修改 `TraceStatService.cs` 的默认参数：

```csharp
// 优化前
public Int32 FlowPeriod { get; set; } = 5;
public Int32 BatchPeriod { get; set; } = 30;

private readonly DayQueue _dayQueue = new() { Period = 60 };
private readonly HourQueue _hourQueue = new() { Period = 60 };
private readonly MinuteQueue _minuteQueue = new() { Period = 60 };
private readonly AppMinuteQueue _appMinuteQueue = new() { Period = 60 };

// 优化后
public Int32 FlowPeriod { get; set; } = 30;      // 5秒 → 30秒
public Int32 BatchPeriod { get; set; } = 60;     // 30秒 → 60秒

private readonly DayQueue _dayQueue = new() { Period = 180 };      // 60秒 → 180秒
private readonly HourQueue _hourQueue = new() { Period = 180 };    // 60秒 → 180秒
private readonly MinuteQueue _minuteQueue = new() { Period = 120 }; // 60秒 → 120秒（告警相关，稍短）
private readonly AppMinuteQueue _appMinuteQueue = new() { Period = 120 }; // 同上
```

**风险评估**：低。批量计算能完全修正流式计算偏差。

### 3.2 第二阶段：精简流式计算（中风险）

**当前**：流式计算同时更新 4 个统计维度
**优化**：流式计算只更新分钟级（`TraceMinuteStat` + `AppMinuteStat`），小时/天级交给批量计算

```csharp
/// <summary>流式计算，增量累加</summary>
private void DoFlowStat(Object state)
{
    if (_queue.IsEmpty) return;

    using var span = _tracer?.NewSpan("TraceFlowStat", new { queue = _count });

    var count = 100_000;
    while (count-- > 0)
    {
        if (!_queue.TryDequeue(out var td)) break;
        Interlocked.Decrement(ref _count);

        if (td.AppId <= 0 || td.Name.IsNullOrEmpty()) continue;

        // ========== 优化：只保留分钟级统计 ==========
        
        // 分钟统计（保留 - 告警数据源）
        {
            var st = _minuteQueue.GetOrAdd(td.StatMinute, td.AppId, td.ItemId, out var key);
            st.Total += td.Total;
            st.Errors += td.Errors;
            st.TotalCost += td.TotalCost;
            if (st.MaxCost < td.MaxCost) st.MaxCost = td.MaxCost;
            if (st.MinCost <= 0 || st.MinCost > td.MinCost && td.MinCost > 0) st.MinCost = td.MinCost;
            st.TotalValue += td.TotalValue;
            _minuteQueue.Commit(key);
        }

        // 应用分钟统计（保留 - 告警数据源）
        {
            var st = _appMinuteQueue.GetOrAdd(td.StatMinute, td.AppId, out var key);
            st.Total += td.Total;
            st.Errors += td.Errors;
            st.TotalCost += td.TotalCost;
            if (st.MaxCost < td.MaxCost) st.MaxCost = td.MaxCost;
            if (st.MinCost <= 0 || st.MinCost > td.MinCost && td.MinCost > 0) st.MinCost = td.MinCost;
            _appMinuteQueue.Commit(key);
        }

        // ========== 移除：小时/天统计交给批量计算 ==========
        // 原来的 _dayQueue 和 _hourQueue 流式更新代码删除
        
        if (span != null) span.Value++;
    }
}
```

**风险评估**：中等。小时/天统计会有短暂延迟，但批量计算会在60秒内修正。

### 3.3 第三阶段：按需计算（进阶优化）

**目标**：99% 的统计数据无人查看，可以大幅降低这些数据的计算频率

#### 3.3.1 引入关注机制

```csharp
/// <summary>追踪统计服务（优化版）</summary>
public class TraceStatService : ITraceStatService
{
    // ... 原有字段 ...

    /// <summary>关注的应用列表（正在被查看的应用）</summary>
    private readonly ConcurrentDictionary<Int32, DateTime> _focusedApps = new();

    /// <summary>默认统计周期（无人关注时）</summary>
    public Int32 DefaultFlowPeriod { get; set; } = 60;  // 60秒

    /// <summary>关注统计周期（有人查看时）</summary>
    public Int32 FocusedFlowPeriod { get; set; } = 10;  // 10秒

    /// <summary>标记应用为关注状态（有人正在查看）</summary>
    /// <param name="appId">应用ID</param>
    /// <param name="duration">关注持续时间，默认5分钟</param>
    public void Focus(Int32 appId, TimeSpan? duration = null)
    {
        var expire = DateTime.Now.Add(duration ?? TimeSpan.FromMinutes(5));
        _focusedApps.AddOrUpdate(appId, expire, (k, v) => expire);
    }

    /// <summary>判断应用是否被关注</summary>
    private Boolean IsFocused(Int32 appId)
    {
        if (_focusedApps.TryGetValue(appId, out var expire))
        {
            if (expire > DateTime.Now) return true;
            _focusedApps.TryRemove(appId, out _);
        }
        return false;
    }

    /// <summary>清理过期的关注</summary>
    private void CleanupFocused()
    {
        var now = DateTime.Now;
        foreach (var kv in _focusedApps)
        {
            if (kv.Value < now)
                _focusedApps.TryRemove(kv.Key, out _);
        }
    }
}
```

#### 3.3.2 Web 端集成

在 `Stardust.Web` 的统计页面添加关注通知：

```csharp
// 统计页面 Controller
public class TraceStatController : ControllerBase
{
    private readonly ITraceStatService _statService;

    [HttpGet]
    public IActionResult Index(Int32 appId)
    {
        // 用户正在查看此应用的统计数据
        // 通知统计服务加速计算
        _statService.Focus(appId, TimeSpan.FromMinutes(5));
        
        // ... 原有逻辑 ...
    }
}
```

---

## 4. 实施步骤

### 4.1 步骤一：参数调优（立即可做）

1. 修改 `TraceStatService.cs` 的默认参数
2. 无需重启，可通过配置文件热更新（如果支持）
3. 观察 1~2 天，确认告警延迟在可接受范围

### 4.2 步骤二：精简流式计算

1. 修改 `DoFlowStat` 方法，移除小时/天统计
2. 确保 `DoBatchStat` 能正确计算小时/天统计
3. 测试验证数据准确性

### 4.3 步骤三：按需计算（可选）

1. 实现 `Focus` 机制
2. Web 端集成
3. 灰度上线

---

## 5. 代码修改清单

### 5.1 TraceStatService.cs 修改

```diff
public class TraceStatService : ITraceStatService
{
-   public Int32 FlowPeriod { get; set; } = 5;
-   public Int32 BatchPeriod { get; set; } = 30;
+   public Int32 FlowPeriod { get; set; } = 30;
+   public Int32 BatchPeriod { get; set; } = 60;

-   private readonly DayQueue _dayQueue = new() { Period = 60 };
-   private readonly HourQueue _hourQueue = new() { Period = 60 };
-   private readonly MinuteQueue _minuteQueue = new() { Period = 60 };
-   private readonly AppMinuteQueue _appMinuteQueue = new() { Period = 60 };
+   private readonly DayQueue _dayQueue = new() { Period = 180 };
+   private readonly HourQueue _hourQueue = new() { Period = 180 };
+   private readonly MinuteQueue _minuteQueue = new() { Period = 120 };
+   private readonly AppMinuteQueue _appMinuteQueue = new() { Period = 120 };
```

### 5.2 DoFlowStat 方法优化

```diff
private void DoFlowStat(Object state)
{
    // ... 前置代码 ...

    while (count-- > 0)
    {
        // ... 前置检查 ...

-       // 每日
-       {
-           var st = _dayQueue.GetOrAdd(td.StatDate, td.AppId, td.ItemId, out var key);
-           // ... 统计代码 ...
-           _dayQueue.Commit(key);
-       }
-
-       // 小时
-       {
-           var st = _hourQueue.GetOrAdd(td.StatHour, td.AppId, td.ItemId, out var key);
-           // ... 统计代码 ...
-           _hourQueue.Commit(key);
-       }

        // 分钟（保留）
        {
            var st = _minuteQueue.GetOrAdd(td.StatMinute, td.AppId, td.ItemId, out var key);
            // ... 统计代码 ...
            _minuteQueue.Commit(key);
        }

        // 应用分钟（保留）
        {
            var st = _appMinuteQueue.GetOrAdd(td.StatMinute, td.AppId, out var key);
            // ... 统计代码 ...
            _appMinuteQueue.Commit(key);
        }
    }
}
```

---

## 6. 风险与回滚

### 6.1 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 告警延迟增加 | 低 | 中 | 可接受范围内（3-5分钟） |
| 统计数据短暂不准确 | 低 | 低 | 批量计算会修正 |
| 用户体验下降 | 低 | 低 | 按需计算可加速关注应用 |

### 6.2 回滚方案

如果优化后出现问题，可以：

1. **快速回滚**：将参数改回原值
2. **部分回滚**：只回滚延迟队列周期，保留流式计算降频

### 6.3 监控指标

优化后需要关注：

| 指标 | 阈值 | 说明 |
|------|------|------|
| _queue 积压量 | < 10000 | 超过说明流式计算太慢 |
| 告警延迟 | < 5分钟 | 超过需要调整参数 |
| CPU 使用率 | < 50% | 优化目标 |
| 数据库 IO | 下降 50%+ | 优化目标 |

---

## 7. 后续优化方向

### 7.1 配置可热更新

将统计参数移到配置文件，支持运行时调整：

```json
{
  "TraceStat": {
    "FlowPeriod": 30,
    "BatchPeriod": 60,
    "DayQueuePeriod": 180,
    "HourQueuePeriod": 180,
    "MinuteQueuePeriod": 120,
    "AppMinuteQueuePeriod": 120
  }
}
```

### 7.2 智能调度

根据当前负载动态调整统计频率：

- 高峰期：降低频率，保护数据库
- 低谷期：提高频率，加速统计

### 7.3 分布式部署

如果单机无法满足需求：

- 统计服务独立部署
- 按应用分片处理
- 使用消息队列解耦

---

## 8. 总结

本优化方案针对星尘监控的核心性能瓶颈――统计服务的频繁 UPDATE 操作，提出了分阶段的优化策略：

1. **参数调优**：简单有效，立即可做，预计减少 60% 负载
2. **精简流式计算**：减少冗余计算，进一步降低 CPU 占用
3. **按需计算**：精细化调度，最大化利用计算资源

预计优化后：
- **CPU 使用率**：从 80%+ 降至 30%-
- **数据库 IO**：减少 60%+
- **告警延迟**：2~3 分钟（可接受范围）

建议按步骤逐步实施，每步完成后观察效果再进行下一步。

---

## 9. 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | v1.0 |
| 创建日期 | 2026-02-03 |
| 作者 | NewLife 团队 |
| 状态 | 已实施参数调优和流式计算精简 |
